<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="origin-trial" content="AkJhKw11U0oD/cBDmd0l8xGbgR1NrdsD8U+0k65KGHaBABshLRJ3FPp+M2QFjru6LdtS5BCIrw1wXGaldN6LEgYAAABVeyJvcmlnaW4iOiJodHRwczovL2lvLmV5YWxncnVzcy5jb206NDQzIiwiZmVhdHVyZSI6IkFJV3JpdGVyQVBJIiwiZXhwaXJ5IjoxNzY5NDcyMDAwfQ==">
  <meta http-equiv="origin-trial" content="AlLaBwduz2ip9mxvIOb5LpctBl11hu52Zfta6BsI4byS7llxpalNd3prA0UuSE0L4uYcNQcr5pMvgzrkf0+2nwwAAABXeyJvcmlnaW4iOiJodHRwczovL2lvLmV5YWxncnVzcy5jb206NDQzIiwiZmVhdHVyZSI6IkFJUmV3cml0ZXJBUEkiLCJleHBpcnkiOjE3Njk0NzIwMDB9">
  
  <style>
    :root {
      color-scheme: light dark;
    }
    
    body {
      display: grid;
      height: 100vh;
      height: 100dvh;
      margin: 0;
      overflow: clip;
    }
    
    .hide,
    #controls > input,
    #controls:has(#full:checked).conditional_hide,
    #controls:has(#full:checked) :not(:is(#full, #full + label)),
    #controls:has(#full:checked) ~ #editor,
    #llm:is(:not(:checked), :disabled) ~ #run_stop,
    #controls:has(#llm:is(:not(:checked), :disabled)) ~ #editor #prom {
      display: none !important;
    }
    
    #controls {
      display: flex;
      flex-direction: column;
      position: fixed;
      -webkit-user-select: none;
      user-select: none;
    }
    
    #controls:not(:has(#full:checked)) {
      background-color: Field;
    }
    
    #controls > * {
      background-color: inherit;
      border: none;
      filter: saturate(0);
      font-size: initial;
      padding-block: .5em;
      padding-inline: 0;
      text-align: center;
    }
    
    @media (hover: hover) {
      #controls > :hover {
        background-color: light-dark(#e0e0e0, #585858);
      }
      
      #controls > :focus-visible {
        outline-offset: -1px;
        outline-style: solid;
      }
    }
    
    #full + label::before {
      content: '\21f1';
    }
    
    #full:checked + label::before {
      content: '\21f2';
      text-shadow: 1px 0 Field;
    }
    
    #controls > :is(
      :is(
        :not(input[type=checkbox]:not(#full) + label, .running),
        input[type=checkbox]:not(#full, :checked) + label,
      ):active,
      input[type=checkbox]:not(#full):checked + label:not(:active),
      .running:not(:active)
    ) {
      background-color: light-dark(#c0c0c0, #787878);
    }
    
    #llm:disabled + label {
      cursor: pointer;
      opacity: 35%;
      rotate: .5turn;
    }
    
    #run_stop::before {
      content: '\25b6\fe0e';
    }
    
    #run_stop.running::before {
      content: '\2b1b\fe0e';
    }
    
    #run_stop.running.loop::before {
      content: '\2b1b\fe0e\35a';
    }
    
    #share_button {
      position: relative;
      text-shadow: 0 0 black;
    }
    
    #share_button::before {
      bottom: 0;
      content: '\2714';
      font-size: .8em;
      opacity: 0;
      position: absolute;
      right: 0;
      transition: opacity 5s ease-in;
    }
    
    #share_button.copied::before {
      opacity: 1;
      transition: none;
    }
    
    #controls a {
      text-decoration: none;
    }
    
    dialog {
      line-height: 2;
      margin-left: 2rem;
      padding: 0;
      text-align: right;
    }
    
    dialog > div {
      padding: 1rem;
    }
    
    dialog > div > p:first-child {
      font-variant-caps: all-small-caps;
      font-size: .8em;
      margin-top: 0;
      text-align: center;
    }
    
    dialog label {
      display: block;
    }
    
    #editor {
      display: grid;
    }
    
    #controls:has(#wrap:not(:checked)) ~ #editor textarea {
      white-space: pre;
    }
    
    iframe, textarea {
      border: none;
      box-sizing: border-box;
      margin: 0;
      outline: none;
    }
    
    textarea {
      font-size: calc(1rem * var(--font_size_factor, 1));
      padding: 1rem;
      padding-left: 1.5rem;
      tab-size: 2ch;
    }
    
    #code {
      height: 50vh;
      height: 50dvh;
      max-height: 100vh;
      max-height: 100dvh;
      max-width: 100vw;
      width: 50vw;
    }
    
    #prom {
      min-height: 0;
      min-width: 0;
      resize: none;
    }
    
    iframe {
      height: 100%;
      max-height: 100vh;
      max-height: 100dvh;
      max-width: 100vw;
      width: 100%;
    }
    
    #controls:has(#full:checked) ~ iframe {
      border: none;
      height: 100vh !important;
      height: 100dvh !important;
      width: 100vw !important;
    }
    
    #controls:has(#llm:not(:checked)) ~ #prom {
      border: none;
    }
    
    @media (aspect-ratio > 16 / 18) {
      body {
        grid-template-columns: auto 1fr;
      }
      
      #editor {
        grid-template-rows: auto 1fr;
        width: min-content;
      }
      
      #controls:has(#llm:not(:checked)) ~ #editor #code {
        height: 100vh !important;
        height: 100dvh !important;
        resize: horizontal;
      }
      
      #code {
        height: 80vh;
        height: 80dvh;
      }
      
      #prom {
        border-top: 1px solid;
      }
      
      iframe {
        border-left: 1px solid;
      }
    }
    
    @media (aspect-ratio <= 16 / 18) {
      body {
        grid-template-rows: auto 1fr;
      }
      
      #editor {
        grid-template-columns: auto 1fr;
      }
      
      #code {
        min-height: 100%;
      }
      
      #controls:has(#llm:not(:checked)) ~ #editor #code {
        resize: vertical;
        width: 100vw !important;
      }
      
      #prom {
        border-left: 1px solid;
      }
      
      iframe {
        border-top: 1px solid;
      }
    }
  </style>
</head>
<body onload="update(location.hash)" onpopstate="update(location.hash, true)">
  <div id="controls" onpointerdown="event.preventDefault()">
    <input id="full" type="checkbox" autocomplete="off" aria-controls="editor" aria-expanded="true" aria-keyshortcuts="Ctrl+Shift+F">
    <label for="full" tabindex="0" title="Show/hide editor [Ctrl+Shift+F]"></label>
    <input id="wrap" type="checkbox" checked autocomplete="off">
    <label for="wrap" tabindex="0" title="Word wrap">w</label>
    <input id="llm" type="checkbox" autocomplete="off" aria-controls="prom" aria-expanded="false">
    <label for="llm" tabindex="0" title="LLM">&#x1f916;</label>
    <button id="run_stop" onclick="generate(event.ctrlKey || event.metaKey || event.button == 1)" aria-keyshortcuts="Ctrl+Enter Ctrl+Shift+Enter" title="Run/stop generation [Ctrl+Enter]
Looping/no-loop generation [Ctrl+Shift+Enter] or [Ctrl+Click]"></button>
    <button onclick="update()" title="Reload iframe">&#x27f3;</button>
    <button onclick="new_editor(event)" title="New">&#x1f195;</button>
    <input id="open_button" type="file" multiple>
    <label for="open_button" tabindex="0" title="Open file(s)">&#x1f4c2;&#xfe0e;</label>
    <button onclick="save()" aria-keyshortcuts="Ctrl+S" title="Save file [Ctrl+S]">&#x1f4be;&#xfe0e;</button>
    <button id="share_button" onclick="share(event.ctrlKey || event.metaKey || event.button == 1)" title="Share (or [Ctrl+Click] to copy link as HTML,
and use Ctrl+V to paste in Moodle)">&#x1f517;</button>
    <input id="broadcast" autocomplete="off">
    <label for="broadcast" tabindex="0" title="Broadcast (public)" onclick="if (broadcast.type != 'checkbox') {broadcast.checked = false; broadcast.type = 'checkbox'}">&#x1f52b;&#xfe0e;</label>
    <a href="https://github.com/eyaler/ediking" target="_blank" title="Code and documentation on GitHub">&#x1f431;</a>
  </div>
  
  <dialog id="broadcast_dialog" closedby="any" tabindex="-1">  <!-- Fix for Firefox issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1934522 -->
    <div>
      <p>Broadcasting live! All data is public!</p>
      <label>
        Session:
        <input id="broadcast_session" type="number" inputmode="numeric" autocomplete="off" min="1" placeholder="Number (optional)" required>
      </label>
      <label>
        User:
        <input id="broadcast_user" type="text" autocomplete="off">
      </label>
      <label>
        Group:
        <input id="broadcast_group" type="text" autocomplete="off">
      </label>
      <label>
        Key:
        <input id="broadcast_key" type="text" autocomplete="off">
      </label>
    </div>
  </dialog>
  
  <div id="editor">
    <textarea id="code" autocomplete="off" autocorrect="off" autofocus placeholder="Code here." oninput="update()"></textarea>
    <textarea id="prom" autocomplete="off" placeholder="Prompt here." rows="1"></textarea>
  </div>
  
  <script>
    'use strict'
    let prev_key, active_before_update, prom_active, llm_started, writer, rewriter, controller, user_click, loop, was_loop, gun, pad
    let font_size_factor = 1
    const font_size_factor_step = .05
    const min_font_size_factor = .1
    const max_font_size_factor = 10
    const persistent_params = ['temp', 'noai']
    const broadcasted_params = ['temp', 'prompt', 'pause']
    const max_safe_iters = 1000
    const default_template = 'html'
    const uniform_block_comments = true
    const gun_peers = ['https://gun-manhattan.herokuapp.com/gun', 'https://try.axe.eco/gun', 'https://test.era.eco/gun', 'https://peer.wallie.io/gun']
    
    const templates = {  // Use '  ' (two spaces; will be removed) to denote caret location
      1: ``,
      html: `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
	<style>
		body {
			
		}
		
		
	</style>
</head>
<body>
	  
</body>
</html>`,
      js: `<script>

  

<\/script>`,
      p5: `<script src="https://cdn.jsdelivr.net/npm/p5"><\/script>
<style>body {margin: 0} canvas {display: block}</style>
<script>'use strict'
// Globals:
  

function setup() {
	createCanvas(windowWidth, windowHeight)
	
}

function draw() {
	
}

function windowResized() {
	resizeCanvas(windowWidth, windowHeight)
}
<\/script>`,
      q5: `<script src="https://q5js.org/q5.min.js"><\/script>
<style>canvas {display: block}</style>
<script>'use strict'
createCanvas()
  

function draw() {
	
}

function windowResized() {
	resizeCanvas()
}
<\/script>`,
      0: `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
		body {
			display: flex;
			flex-direction: column;
			font-family: system-ui;
			font-size: 1.5em;
			margin: 0;
			min-height: 100vh;
			min-height: 100dvh;
		}
		
		div {
			align-items: center;
			display: flex;
			flex-direction: column;
			flex-grow: 1;
			text-align: center;
			width: 100%;
		}
		
		div > * {
			flex-grow: 1;
			line-height: max(100%, 2rem);
			margin-block: 1rem;
			margin-inline: 1rem;
			max-width: 70ch;
		}
		
		a {
			color: inherit;
			font-family: monospace;
		}
	</style>
</head>
<body>
	<div style="background-color: darkred; color: pink; font-family: Georgia, serif;">
		<p style="font-size: 4em;">Hi!</p>
		<p>I'm a website.</p>
		<p>And I live in the URL.</p>
	</div>
	<div style="background-color: #ffbb00; color: black;">
		<p>You can edit my code in the adjacent editor.</p>
		<p>If you got <b>Chrome/Edge desktop 138/139+</b>, <b>22/20 GB disk space</b>, and <b>4/5.5 GB GPU</b>... you can use the built-in <b>Gemini Nano / Phi-4-mini LLM</b> to write and edit code. Autovibe mode included.</p>
		<p>By the way, everything here is 100% client-side.</p>
	</div>
	<div style="background-color: blue; color: #00ff00;">
		<p><a href="https://tfi.la/e#recur">Fun with recursion</a></p>
		<p><a href="https://tfi.la/e?loop&prompt=Communicate+with+the+aliens+using+text%2C+shapes+and+colors.+Change+the+previous+message+and+make+it+even+more+psychedelic%21#%3C!DOCTYPE%20html%3E%0A%3Chtml%20lang%3D%22en%22%3E%0A%3Cbody%3E%0A%3Ch1%3EMessage%20to%20the%20aliens...%3C%2Fh1%3E%0A%3C%2Fbody%3E%0A%3C%2Fhtml%3E">Alien translation airlock</a><br><small>(requires LLM)</small></p>
		<p><a href="https://github.com/eyaler/ediking">The code behind the code</a></p>
		<p><small>Made by</small><br><a href="https://eyalgruss.com">Eyal Gruss</a></p>
	</div>
</body>
</html>`,
    }
    
    const iframe = document.createElement('iframe')  // Add iframe dynamically to avoid empty iframe on navigation in Firefox
    
    function log(...args) {
      const doc = iframe.contentDocument
      const html = doc.documentElement
      let log_elem = doc.getElementById('log_elem')
      if (!log_elem) {
        const body = doc.body || html.appendChild(doc.createElement('body'))
        log_elem = doc.createElement('pre')
        log_elem.style.display = 'none'
        body.appendChild(log_elem)
        log_elem.id = 'log_elem'
        log_elem.style.setProperty('--font_size_factor', font_size_factor)
        log_elem.style.font = 'calc(1rem * var(--font_size_factor, 1)) monospace'
        log_elem.style.margin = '1rem .5rem'
        log_elem.style.overflowWrap = 'break-word'
        log_elem.style.whiteSpace = 'pre-wrap'
      }
      if (args.length) {
        log_elem.style.display = 'revert'
        log_elem.textContent += args.map(x => typeof x == 'object' ? JSON.stringify(x, null, 1).replace(/\n\s*/g, ' ') : String(x)).join(' ') + '\n'
        log_elem.scrollIntoView(false)
      }
      return log_elem
    }
    
    function safeLog(...args) {
      const log_elem = log(...args)
      const key = 'data-' + JSON.stringify(Error().stack).toLowerCase().replace(/[^a-z0-9-]+/g, '').slice(-100)
      const cnt = +log_elem.getAttribute(key) + 1
      if (cnt > max_safe_iters) {
        const err = `Suspected infinite loop stopped after ${cnt} iterations`
        log('Error:', err)
        throw Error(err)
      }
      log_elem.setAttribute(key, cnt)
      return log_elem
    }
    
    var safelog = safeLog
    
    function clear() {
      iframe.contentDocument.getElementById('log_elem')?.remove()
    }
    
    function get_code() {
      return code.value
    }
    
    function get_prompt() {
      return prom.value
    }
    
    function get_url_param(key='disp') {
      const val = new URLSearchParams(location.search).get(key)
      if (key == 'prompt')
        return val ?? ''
      return val == '' ? 1 : isNaN(val) ? val : +val
    }
    
    function set_history_state(url, push) {
      try {
        if (!url || push) {
          set_url_param('loop', false)
          history.pushState(history.state, '', url)
        } else
          history.replaceState(history.state, '', url)
      } catch {}  // For iframes
    }
    
    function set_url_param(key, val) {
      const url = new URL(location)
      if (val)
        url.searchParams.set(key, val === true ? '' : val)
      else
        url.searchParams.delete(key)
      set_history_state(url)
      return val
    }
    
    function fix_disp_param() {
      const disp = get_url_param()
      if (!disp && full.checked || disp == 1 && !full.checked)
        set_url_param('disp', full.checked)
    }
    
    function update(hash, pop) {
      if (hash != null) {
        if (pop) {
          controller?.abort('nav')
          fix_disp_param()
        }
        const disp = get_url_param()
        if (!disp == full.checked)
          full.click()
        controls.classList.toggle('conditional_hide', disp == 2)
        controls.classList.toggle('hide', disp == 3)
        check_model()
        if (hash == '#recur')
          code.value = document.documentElement.outerHTML.replaceAll("== '#recur'", "|| '#recur'")
        else if (hash)
          code.value = decodeURIComponent(hash.slice(1))
        else {
          const temp = templates[get_url_param('temp')] ?? templates[0]
          const caret = Math.max(temp.indexOf('  '), 0)
          code.value = temp.replace('  ', '')
          code.setSelectionRange(caret, caret)
        }
        const session = get_url_param('session')
        if (session > 0)
          broadcast_session_value = session
        broadcast_user.value = get_url_param('user') || sessionStorage.getItem('ediking_user') || localStorage.getItem('ediking_user')
        broadcast_group.value = get_url_param('group') || sessionStorage.getItem('ediking_group') || localStorage.getItem('ediking_group')
        broadcast_key.value = get_url_param('key') || sessionStorage.getItem('ediking_key') || localStorage.getItem('ediking_key')
      }
      active_before_update = document.activeElement
      if (self == top)
        console.clear()
      if (get_url_param('pause')) {
        set_url_param('pause', false)
        iframe.srcdoc = ''
      } else
        iframe.srcdoc = code.value
      if (editor.nextSibling != iframe)
        editor.after(iframe)
    }
    
    code.addEventListener('focus', () => prom_active = false)
    prom.addEventListener('focus', () => prom_active = true)
    
    prom.addEventListener('input', () => {
      set_url_param('prompt', prom.value)
      if (prom.value && new URL(location).searchParams.get('prompt') != prom.value && self == top)
        alert(`Too much data to save in URL - truncated to ${location.href.length} chars.`)
    })
    
    function block_drop_nav(e) {
      if (e.dataTransfer.types.includes('Files'))
        e.preventDefault()
    }
    
    iframe.addEventListener('load', () => {
      active_before_update?.focus()
      const doc = iframe.contentDocument
      document.title = doc.title || 'ediKing'
      const meta = document.querySelector('meta[name=description]') || document.head.appendChild(document.createElement('meta'))
      meta.content = doc.querySelector('meta[name=description]')?.content ?? 'ediKing - A client-side HTML/JS editor'
      meta.name = 'description'
      document.head.querySelectorAll('link[rel=icon]').forEach(e => e.remove())
      doc.head.querySelectorAll('link[rel=icon]').forEach(e => document.head.appendChild(e))
      doc.querySelectorAll('a').forEach(a => {
        if (a.origin != location.origin)
          a.target = '_blank'
      })
      if (get_url_param() < 3)
        doc.addEventListener('keydown', global_keys_handler, true)
      ;['dragover', 'drop'].forEach(e => doc.addEventListener(e, block_drop_nav, true))
      set_history_state('#' + encodeURIComponent(code.value))
      if (decodeURIComponent(location.hash.slice(1)) != code.value && self == top)
        alert(`Too much data to save in URL - truncated to ${location.href.length} chars.`)
      put()
    })
    
    full.addEventListener('input', () => {
      fix_disp_param()
      full.ariaExpanded = !full.checked
      
      if (full.checked) {
        if (document.activeElement.tagName.toLowerCase() != 'label')
          iframe.focus()
      } else if (prom_active && !prom.readOnly)
        prom.focus()
      else
        code.focus()
    })
    
    
    // LLM stuff
    
    const chars_to_tokens = 2.5
    const shared_context = {sharedContext: 'Never use external files or remote media! Address any comments marked by FIXME, and remove them.'}
    const fullcode_prompt = 'Output only a complete single-file HTML code (including CSS/JS inside). Popular JS libraries can be used from CDN.'
    
    async function check_model(recheck) {
      const noai = get_url_param('noai') || location.hash == '#recur'
      const writer_availability = !noai && self.Writer && await Writer.availability()
      const rewriter_availability = !noai && self.Rewriter && await Rewriter.availability()
      if (!writer_availability || !rewriter_availability || writer_availability == 'unavailable' || rewriter_availability == 'unavailable') {
        llm.disabled = true
        const label = llm.nextElementSibling
        if (noai)
          label.classList.add('hide')
        else {
          label.role = 'link'
          label.onclick = () => open(navigator.userAgent.includes('Edg') ? 'https://learn.microsoft.com/sr-latn-rs/microsoft-edge/web-platform/writing-assistance-apis' : 'https://developer.chrome.com/docs/ai/writer-api', '_blank')
          label.title = 'Writer/Rewriter APIs not supported\nClick for details!'
        }
      } else if (writer_availability == 'available' && rewriter_availability == 'available')
        if (llm.checked)
          prom.value = get_url_param('prompt')
        else
          llm.click()
      else if (!recheck)
        setTimeout(check_model, 5000, true)  // Delay to deal with https://issues.chromium.org/issues/429183223
    }
    
    function monitor(m) {
      m.addEventListener('downloadprogress', e => {
        if (prom.readOnly)
          prom.value = `Downloading model... ${e.loaded * 100 | 0}%`
      })
    }
    
    llm.addEventListener('click', e => user_click = user_click == null || e.isTrusted)
    
    llm.addEventListener('input', async () => {
      if (llm.checked) {
        if (!llm_started) {
          llm_started = true
          prom.readOnly = true
          prom.value = 'Loading model...'
          run_stop.classList.add('hide')
          try {
            const create_options = {monitor, ...shared_context}
            writer = await Writer.create({...create_options, length: 'long'})
            rewriter = await Rewriter.create(create_options)
            prom.value = get_url_param('prompt')
            prom.readOnly = false
            run_stop.classList.remove('hide')
            if (get_url_param('loop') && llm.checked)
              generate(true)
          } catch (error) {
            llm.checked = false
            console.error(error)
            alert(error)
          }
        } else if (user_click && !prom.readOnly)
          prom.focus()
      } else
        code.focus()
      llm.ariaExpanded = llm.checked
    })
  
    function close_comment(s) {
      return s.replace(/(?<!:)(\/\/[^\n]*)$/, '$1\n')
    }
    
    async function generate(mod, cont_start, cont_end, cont_dir) {
      if (!controller || controller.signal.aborted && mod != null && !run_stop.classList.contains('running'))
        controller = new AbortController()
      
      if (!loop && mod)
        loop = true
      else if (mod != null)
        loop = false
      run_stop.classList.toggle('loop', loop)
      was_loop ||= loop
      set_url_param('loop', loop)
      
      if (!run_stop.classList.contains('running') || mod == null) {
        if (!llm.checked && mod != null)
          llm.click()
        
        code.readOnly = true
        run_stop.classList.add('running')
        
        const abort_signal = {signal: controller.signal}
        
        let code_text = code.value
        let prompt_text = prom.value.trim()
        
        let start = code.selectionStart
        let end = code.selectionEnd
        let dir = code.selectionDirection
        const orig_len = code_text.length
        const trimmed = code_text.trim()
        const partial = start < end && end - start < trimmed.length || cont_start != null && trimmed
        const selection = code.value.slice(start, end).trim()
        
        let code_before = ''
        let code_after = ''
        if (partial) {
          if (cont_start != null) {
            code_before = code_text
            code_text = ''
            start = cont_start
            end = cont_end
            dir = cont_dir
          } else {
            code_before = code_text.slice(0, start)
            code_after = code_text.slice(end)
            code_text = selection
          }
        } else {
          prompt_text = fullcode_prompt + '\n\n' + prompt_text
          code_text = trimmed
        }
        
        const save_code = code.value
        let stream
        let resp = ''
        
        try {
          if (!code_text) {
            if (partial) {
              let before_context = code_before.trim()
              let after_context = code_after.trim()
              let code_context = '\n<!--/* COMPLETE MISSING CODE HERE AND OUTPUT ONLY THIS PART */-->\n'
              prompt_text += '\n\nCURRENT CODE:\n\n'
              while ((before_context || after_context) && (shared_context[sharedContext] + prompt_text + code_context).length < writer.inputQuota * chars_to_tokens) {
                code_context = before_context.slice(-1) + code_context + after_context[0]
                before_context = before_context.slice(0, -1)
                after_context = after_context.slice(1)
              }
              prompt_text += code_context.replaceAll('FIXME', '')
            }
            stream = writer.writeStreaming(prompt_text, abort_signal)
          } else
            stream = rewriter.rewriteStreaming(code_text, {context: prompt_text, ...abort_signal})
          for await (const chunk of stream) {
            resp += chunk
            code.value = close_comment(code_before) + close_comment(resp.replace(/\n?```[^\n]*\n?/g, '')) + code_after
            if (start < end)
              code.setSelectionRange(start, end + code.textLength - orig_len, dir)
          }
          if (!was_loop && !code.value.includes('</html>') && !code_after.trim() && !controller.signal.aborted)
            await generate(null, start, start < end ? end + code.textLength - orig_len : end, dir)
        } catch (error) {
          if (error.name == 'QuotaExceededError') {
            loop = false
            const msg = `Error: LLM input (code + prompt) is ${error.requested.toLocaleString()} tokens,\nbut model is limited to ${error.quota.toLocaleString()} tokens.`
            console.error(msg)
            alert(msg)
          } else if (error.name != 'AbortError' && error != 'nav') {
            console.error(error)
            if (was_loop)
              code.value = save_code
            else
              alert(error)
          }
        }
        if (start < end)
          code.setSelectionRange(start, end + code.textLength - orig_len, dir)
        if (!controller.signal.aborted || controller.signal.reason != 'nav') {
          if (code.value != save_code)
            set_history_state()
          update()
        }
        if (loop && !controller.signal.aborted)
          await generate()
        else {
          run_stop.classList.remove('running')
          code.readOnly = false
          was_loop = false
        }
      } else if (!mod)
        controller?.abort()
    }
    
    
    // New, open, save, share, broadcast
    
    function new_editor(e) {
      const search = new URLSearchParams(location.search)
      ;[...search.keys()].forEach(k => {
        if (!persistent_params.includes(k))
          search.delete(k)
      })
      if (!search.has('temp') && default_template)
        search.set('temp', default_template)
      const url = location.pathname + '?' + search
      
      if (e.ctrlKey || e.metaKey || e.button == 1)
        window.open(url, '_blank')
      else {
        controller?.abort('nav')
        set_history_state(url, true)
        code.focus()
        update('')
      }
    }
    
    function open_files(files) {
      let have_code
      let have_prompt
      ;[...files].forEach(file => {
        const reader = new FileReader()
        reader.onload = () => {
          let content = reader.result
          if (file.name.endsWith('.prompt') || file.name.endsWith('.poml')) {
            if (!prom.readOnly) {
              if (have_prompt)
                prom.value += '\n\n'
              else
                prom.value = ''
              prom.value += content
              have_prompt = true
              if (!llm.checked) {
                user_click = null
                llm.click()
              } else
                prom.focus()
            }
          } else if (!code.readOnly) {
            if (have_code)
              code.value += '\n\n'
            else
              code.value = ''
            const indented = `\n\t\t${content.split('\n').join('\n\t\t')}\n\t`
            if (file.name.endsWith('.css') || file.type == 'text/css')
              content = `\t<style>${indented}</style>`
            else if (file.name.endsWith('.js') || file.type == 'application/x-javascript')
              content = `\t<script>${indented}<\/script>`
            code.value += content
            have_code = true
            code.focus()
          }
          update()
        }
        reader.readAsText(file)
      })
    }
    
    editor.addEventListener('dragover', e => {
      if (e.dataTransfer.types.includes('Files')) {
        e.preventDefault()
        e.dataTransfer.dropEffect = 'copy'
      }
    })
    
    editor.addEventListener('drop', e => {
      const files = e.dataTransfer.files
      if (files.length) {
        e.preventDefault()
        open_files(files)
      }
    })
    
    open_button.addEventListener('change', e => open_files(e.currentTarget.files))
    
    function save() {
      const file = new Blob([iframe.srcdoc], {type: 'text/html'})
      const a = document.createElement('a')
      a.href = URL.createObjectURL(file)
      a.download = 'index.html'
      a.click()
    }
    
    if (!navigator.share) {
      share_button.title = `Copy link as HTML
(use [Ctrl+V] to paste in Moodle)`
    }
    
    function toggle_checkmark() {
      share_button.classList.add('copied')
      share_button.offsetWidth  // Restart transition. See: https://css-tricks.com/restart-css-animation/
      share_button.classList.remove('copied')
    }
    
    function share(mod) {
      (!mod && navigator.share?.({url: location, text: location, title: document.title}).catch(() => {}))
       || navigator.clipboard.write?.([new ClipboardItem({'text/html': new Blob([`<a href="${location}">${location}</a>`], {type: 'text/html'}), 'text/plain': new Blob([location], {type: 'text/plain'})})]).then(toggle_checkmark)
       || navigator.clipboard.writeText(location).then(toggle_checkmark)
    }
    
    broadcast_dialog.close()
    
    async function load_script(script) {
      return new Promise((resolve, reject) => {
        const s = document.head.appendChild(document.createElement('script'))
        s.onload = () => resolve(s)
        s.onerror = error => reject(error)
        s.src = script
      })
    }
    
    async function put() {
      if (pad)
        if (broadcast.checked) {
          const url = new URL(location)
          ;[...url.searchParams.keys()].forEach(k => {
            if (!broadcasted_params.includes(k))
              url.searchParams.delete(k)
          })
          const content = broadcast_key.value ? btoa(String.fromCharCode(...new TextEncoder().encode(url).map((b, i) => b ^ broadcast_key.value.toLowerCase().charCodeAt(i % broadcast_key.value.length)))) : url.href
          pad.put({content: content, modified: Date.now(), session: broadcast_session.value, user: broadcast_user.value, group: broadcast_group.value})
        } else
          pad.put(null)
    }
    
    function stop_gun() {
      pad?.put(null)
    }
    
    broadcast.addEventListener('input', async () => {
      if (self != top)
        broadcast.checked = false
      if (broadcast.checked) {
        broadcast_dialog.showModal()
        if (!gun) {
          gun = true
          await load_script('https://cdn.jsdelivr.net/npm/gun@0.2020.1241/gun.min.js')
          await load_script('https://cdn.jsdelivr.net/npm/gun@0.2020.1241/lib/webrtc.min.js')
          gun = Gun({peers: gun_peers, localStorage: false, rtc: {room: 'ediking'}})
          pad = gun.get('ediking').get(Date.now() + '_' + crypto.randomUUID())
          addEventListener('online', () => {
            gun.opt(gun_peers)
            put()
          })
        }
        addEventListener('beforeunload', stop_gun)
      } else
        removeEventListener('beforeunload', stop_gun)
      put()
    })
    
    broadcast_dialog.querySelectorAll('input').forEach(e => e.addEventListener('input', () => {
      const field = e.id.split('_')[1]
      if (field != 'session') {
        const field_key = 'ediking_' + field
        sessionStorage[field_key] = e.value
        localStorage[field_key] = e.value
      } if (field == 'key')
        put()
      else if (pad) {
        const data = {modified: Date.now()}
        data[field] = e.value
        pad.put(data)
      }
    }))
    
    broadcast_dialog.addEventListener('click', e => {
      if (e.target == e.currentTarget)
        broadcast_dialog.close()
    })
    
    broadcast_dialog.addEventListener('keydown', e => {
      if (e.key == 'Enter') {
        const inputs = [...broadcast_dialog.querySelectorAll('input')]
        for (const i in inputs)
          if (inputs[i] == document.activeElement) {
            if (i == inputs.length - 1)
              broadcast_dialog.close()
            else
              inputs[+i + 1].focus()
            break
          }
      } else if (e.key == 'Escape')
        broadcast_dialog.close()
    })
    
    
    // Keyboard input
    
    function get_layout_key(e) {
      let key = e.key.toLowerCase()
      if (!e.key.match(/^[a-z]$/) && e.code.match(/^Key[A-Z]$/))  // For Hebrew keyboard
        key = e.code[3].toLowerCase()
      return key
    }
    
    document.addEventListener('keydown', global_keys_handler)
    
    document.addEventListener('keydown', e => {
      if ((e.altKey || e.getModifierState?.('AltGraph')) && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        let font_size_change = true
        if (e.key == '0' || e.code == 'Numpad0')  // For AZERTY keyboard
          font_size_factor = 1
        else if (e.key == '-' || e.code == 'Minus' && !'+?\\'.includes(e.key))
          font_size_factor = Math.max(font_size_factor - font_size_factor_step, min_font_size_factor)
        else if (e.key == '=' || e.code == 'Equal' && !'-_'.includes(e.key))
          font_size_factor = Math.min(font_size_factor + font_size_factor_step, max_font_size_factor)
        else
          font_size_change = false
        if (font_size_change) {
          e.preventDefault()
          editor.style.setProperty('--font_size_factor', font_size_factor)
          iframe.contentDocument.getElementById('log_elem')?.style.setProperty('--font_size_factor', font_size_factor)
        }
      }
    })
    
    function global_keys_handler(e) {
      const layout_key = get_layout_key(e)
      if (!e.altKey && !e.getModifierState?.('AltGraph') && (e.ctrlKey || e.metaKey)
          && (layout_key == 'f' && e.shiftKey
              || e.key == 'Enter' && writer && rewriter
              || layout_key == 's' && !e.shiftKey)) {
        e.preventDefault()
        if (layout_key == 'f')
          full.click()
        else if (e.key == 'Enter')
          generate(e.shiftKey)
        else if (layout_key == 's')
          save()
      }
    }
    
    controls.querySelectorAll('label').forEach(label => label.addEventListener('keydown', e => {
      if ((e.key == 'Enter' || e.key == ' ') && !e.altKey && !e.getModifierState?.('AltGraph') && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        e.preventDefault()
        label.click()
      }
    }))
    
    function safe_last_index_of_newline(text, pos) {
      return (pos > 0) * (text.lastIndexOf('\n', pos - 1) + 1)
    }
    
    function safe_insert(text, len) {  // Protect from Chromium issues: https://issues.chromium.org/issues/442551790 , https://issues.chromium.org/issues/442600643
      if (text)
        document.execCommand('insertText', false, text)
      else if (len)
        document.execCommand('delete')
    }
    
    editor.addEventListener('copy', e => {  // With no selection - Duplicate line
      const textarea = e.target
      if (document.execCommand && textarea.selectionStart == textarea.selectionEnd) {
        e.preventDefault()
        const text = textarea.value + '\n'
        const start = textarea.selectionStart
        const transposed = text.slice(start, text.indexOf('\n', start) + 1) + text.slice(safe_last_index_of_newline(text, start), start)
        safe_insert(transposed)
        textarea.setSelectionRange(start + transposed.length, start + transposed.length)
      }
    })
    
    editor.addEventListener('cut', e => {  // With no selection - Delete line
      const textarea = e.target
      if (document.execCommand && textarea.selectionStart == textarea.selectionEnd) {
        e.preventDefault()
        const text = textarea.value + '\n'
        const start = textarea.selectionStart
        const line_start = safe_last_index_of_newline(text, start)
        const line_end = text.indexOf('\n', start) + 1
        const next_line_end = text.indexOf('\n', line_end)
        textarea.setSelectionRange(Math.max(0, line_start + Math.min(0, next_line_end)), line_end)
        document.execCommand('delete')
        let caret
        if (next_line_end == -1)
          caret = Math.min(line_start - 1, safe_last_index_of_newline(text, line_start - 1) + start - line_start)
        else
          caret = Math.min(start, line_start + next_line_end - line_end)
        textarea.setSelectionRange(caret, caret)
      }
    })
    
    editor.addEventListener('pointerdown', () => prev_key = null)
    
    editor.addEventListener('keydown', e => {
      if (document.execCommand && !e.altKey && !e.getModifierState?.('AltGraph')
          && (['Enter', 'Home', 'End', 'Tab'].includes(e.key) && !e.ctrlKey && !e.metaKey
              || e.key == '/' && (e.ctrlKey || e.metaKey) && !e.shiftKey)) {
        if (e.key != 'End' || prev_key == 'End')
          e.preventDefault()
        const textarea = e.target
        const text = textarea.value
        const start = textarea.selectionStart
        const end = textarea.selectionEnd
        const dir = textarea.selectionDirection
        
        if (e.key == 'Enter') {  // New line with current or coding-language-based extra indentation
          let caret = start
          let slice_end
          if (e.shiftKey)  // Skip to line end beforehand
            caret = textarea.selectionStart = textarea.selectionEnd = (text + '\n').indexOf('\n', dir == 'backward' ? start : end)
          else
            slice_end = start
          const line_start = safe_last_index_of_newline(text, caret)
          let indent = '\n' + text.slice(line_start, slice_end).match(/^[ \t]*/)
          if (text.slice(line_start, caret).match(/([{[(:]|=>|<(div|g|p)\b[^>]*>)\s*$/))
            indent += indent.endsWith('  ') ? '  ' : '\t'
          safe_insert(indent)
        }
        
        else if (e.key == 'Home') {  // Move caret to indentation; if already there, move to logical line start (`Shift` for selection)
          let [caret, anti_caret] = dir == 'backward' ? [start, end] : [end, start]
          const line_start = safe_last_index_of_newline(text, caret)
          const whitespace = text.slice(line_start).match(/^[ \t]*/)[0].length
          const indent = line_start + (caret == line_start + whitespace ? 0 : whitespace)
          caret = Math.max(start, anti_caret)
          if (e.shiftKey && caret < indent) {
            textarea.selectionStart = caret
            textarea.selectionDirection = 'forward'
          } else
            textarea.selectionStart = indent
          if (e.shiftKey && anti_caret > indent) {
            textarea.selectionEnd = anti_caret
            textarea.selectionDirection = 'backward'
          } else
            textarea.selectionEnd = indent
          if (!wrap.checked)
            textarea.scrollLeft = 0
        }
        
        else if (e.key == 'End' && prev_key == 'End') {  // For wrapped lines, second press moves caret to logical line end (`Shift` for selection)
          const caret = (text + '\n').indexOf('\n', start)
          if (e.shiftKey && textarea.selectionEnd > caret && dir == 'backward')
            textarea.selectionStart = caret
          else {
            textarea.selectionEnd = caret
            if (!e.shiftKey)
              textarea.selectionStart = caret
          }
        }
        
        else if (e.key == 'Tab') {  // Indent / unindent at caret or multi-line for selection
          if (end > start) {
            const block_start = safe_last_index_of_newline(text, start)
            let indented = text.slice(block_start, end)
            let new_start
            if (e.shiftKey) {
              indented = indented.replace(/(?<=^|\n(?!$))(\t| {1,2})/g, '')
              new_start = Math.max(start - 1, block_start)
            } else {
              indented = '\t' + indented.replace(/\n(?!$)/g, '\n\t')
              new_start = start + 1
            }
            textarea.selectionStart = block_start
            safe_insert(indented, end - start)
            textarea.setSelectionRange(new_start, block_start + indented.length, dir)
          } else if (!e.shiftKey)
            safe_insert('\t')
          else if (text[start - 1] == '\t')
            document.execCommand('delete')
          else if (text[start] == '\t')
            document.execCommand('forwardDelete')
          else if (start > 1 && text.slice(start - 2, start) == '  ') {
            document.execCommand('delete')
            document.execCommand('delete')
          } else if (start && text.slice(start - 1, start + 1) == '  ') {
            document.execCommand('delete')
            document.execCommand('forwardDelete')
          } else if (text[start - 1] == ' ')
            document.execCommand('delete')
          else if (text.slice(start, start + 2) == '  ') {
            document.execCommand('forwardDelete')
            document.execCommand('forwardDelete')
          } else if (text[start] == ' ')
            document.execCommand('forwardDelete')
        }
        
        else if (e.key == '/') {  // Multi-line `//` comment / uncomment
          const block_start = safe_last_index_of_newline(text, start)
          let block_end = end
          if (start == end || text[end - 1] != '\n')
            block_end = (text + '\n').indexOf('\n', end)
          const block = text.slice(block_start, block_end)
          if (start == end && end == block_end && !block.trim())
            safe_insert('// ')
          else {
            const offsets = []
            let missing
            let min_indent
            let commented = block.replace(/(?<=^|\n(?!$))(?=[\t ]*\S|(?<=^)[^\n]*[\n]?$)([\t ]*)(\/\/ ?)?/g, (m, p1, p2, offset) => {
              offsets.push([block_start + offset + p1.length, (p2 || '').length])
              missing ||= !p2
              min_indent ??= p1
              for (const i in min_indent)
                if (min_indent[i] != p1[i]) {
                  min_indent = min_indent.slice(0, i)
                  break
                }
              return p2 ? p1 : p1 + '// '
            })
            if (offsets.length) {
              textarea.selectionStart = block_start
              textarea.selectionEnd = block_end
              if (uniform_block_comments && offsets.length > 1 && missing)
                commented = block.replace(RegExp(`(?<=(^|\n)${min_indent})(?=[\t ]*\\S)`, 'g'), '// ')
              safe_insert(commented, block_end - block_start)
              const new_start = start + (start >= offsets[0][0])*(offsets[0][1] ? -Math.min(offsets[0][1], start - offsets[0][0]) : 3)
              const last = offsets[offsets.length - 1]
              const new_end = block_start + commented.length + end - block_end - (end <= last[0] + last[1])*(last[1] ? -Math.min(last[1], last[0] + last[1] - end) : 3)
              textarea.setSelectionRange(new_start, new_end, dir)
            }
          }
        }
        prev_key = e.key
      } else if (e.key != 'Shift')
        prev_key = null
    })
  </script>
</body>
</html>