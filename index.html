<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="origin-trial" content="AuNKSznJ6LrYQVkRVSU8tEGYGUKwESgcga0TKEK7Y3dn8krurrd7lw8B2nG34/uyRoZE2wPJVX15KTnFvP0JDQ8AAABVeyJvcmlnaW4iOiJodHRwczovL2V5YWxlci5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IkFJV3JpdGVyQVBJIiwiZXhwaXJ5IjoxNzY5NDcyMDAwfQ==">
  <meta http-equiv="origin-trial" content="Am/ycuw2pTJfI5C2G4K2KBHTB9FNmq/LY1sL2e2vt0RP0Kva7ssoFqmeopY9cDeZyPIYLa1LJFSWgwCf6wNaSwcAAABXeyJvcmlnaW4iOiJodHRwczovL2V5YWxlci5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IkFJUmV3cml0ZXJBUEkiLCJleHBpcnkiOjE3Njk0NzIwMDB9">
  <style>
    body {
      display: grid;
      height: 100vh;
      height: 100dvh;
      margin: 0;
      overflow: clip;
    }
    
    .hide,
    #controls input,
    #controls:has(#full:checked).conditional_hide,
    #controls:has(#full:checked) :not(:is(#full, #full + label)),
    #controls:has(#full:checked) ~ #textareas,
    #ai:is(:not(:checked), :disabled) ~ #run_stop,
    #controls:has(#ai:is(:not(:checked), :disabled)) ~ #textareas #prom {
      display: none !important;
    }
    
    #controls {
      display: flex;
      flex-direction: column;
      position: fixed;
      user-select: none;
      -webkit-user-select: none;
    }
    
    #controls > * {
      background-color: inherit;
      border: none;
      filter: saturate(0);
      font-size: initial;
      padding-block: .5em;
      padding-inline: 0;
      text-align: center;
    }
    
    @media (hover: hover) {
      #controls > :is(:hover, :focus-visible) {
        background-color: #e0e0e0;
      }
    }
    
    #full + label::before {
      content: '\21f1';
    }
    
    #full:checked + label::before {
      content: '\21f2';
    }
    
    #controls > :is(:not(:is(#ai, #wrap) + label), :is(#ai, #wrap):not(:checked) + label):active, :is(#ai, #wrap):checked + label:not(:active) {
      background-color: #c0c0c0;
    }
    
    #ai:disabled + label {
      cursor: pointer;
      opacity: 35%;
      rotate: .5turn;
    }
    
    #run_stop::before {
      content: '\25b6\fe0e';
    }

    #run_stop.thinking::before {
      content: '\2b1b\fe0e';
    }
    
    #share_button {
      text-shadow: 0 0 black;
    }

    #controls a {
      text-decoration: none;
    }
    
    #textareas {
      display: grid;
    }
    
    iframe, textarea {
      border: none;
      box-sizing: border-box;
      margin: 0;
      outline: none;
    }
    
    textarea {
      font-size: 1rem;
      padding: 1rem;
      padding-left: 1.5rem;
      tab-size: 1em;
    }
    
    #code {
      height: 50vh;
      height: 50dvh;
      max-height: 100vh;
      max-height: 100dvh;
      max-width: 100vw;
      width: 50vw;
    }
      
    #prom {
      min-height: 0;
      min-width: 0;
      resize: none;
    }
    
    iframe {
      height: 100%;
      max-height: 100vh;
      max-height: 100dvh;
      max-width: 100vw;
      width: 100%;
    }
    
    #controls:has(#full:checked) ~ iframe {
      border: none;
      height: 100vh !important;
      height: 100dvh !important;
      width: 100vw !important;
    }
    
    #controls:has(#ai:not(:checked)) ~ #prom {
      border: none;
    }
    
    @media (aspect-ratio > 16 / 18) {
      body {
        grid-template-columns: auto 1fr;
      }
      
      #textareas {
        grid-template-rows: auto 1fr;
        width: min-content;
      }
      
      #controls:has(#ai:not(:checked)) ~ #textareas #code {
        height: 100vh !important;
        height: 100dvh !important;
        resize: horizontal;
      }
      
      #code {
        height: 80vh;
        height: 80dvh;
      }
      
      #prom {
        border-top: 1px solid;
      }
      
      iframe {
        border-left: 1px solid;
      }
    }
    
    @media (aspect-ratio <= 16 / 18) {
      body {
        grid-template-rows: auto 1fr;
      }
      
      #textareas {
        grid-template-columns: auto 1fr;
      }
      
      #code {
        min-height: 100%;
      }
            
      #controls:has(#ai:not(:checked)) ~ #textareas #code {
        resize: vertical;
        width: 100vw !important;
      }
      
      #prom {
        border-left: 1px solid;
      }
      
      iframe {
        border-top: 1px solid;
      }
    }
  </style>
</head>
<body onload="update(location.hash)">
  <div id="controls">
    <input id="full" autocomplete="off" type="checkbox" aria-controls="textareas" aria-expanded="true" aria-keyshortcuts="Ctrl+Shift+F">
    <label for="full" tabindex="0" title="Show/hide editor
[Ctrl+Shift+F]"></label>
    <input id="wrap" checked type="checkbox">
    <label for="wrap" tabindex="0" title="Word wrap">w</label>
    <input id="ai" autocomplete="off" type="checkbox" aria-controls="prom" aria-expanded="false">
    <label for="ai" tabindex="0" title="Toggle AI">&#x1f916;</label>
    <button id="run_stop" onclick="run_stop_gen()" aria-keyshortcuts="Ctrl+Enter" title="Run/stop generation
[Ctrl+Enter]"></button>
    <button onclick="update()" title="Reload iframe">&#x27f3;</button>
    <button onclick="new_editor(event)" title="New">&#x1f5cb;</button>
    <input id="open_button" autocomplete="off" multiple type="file">
    <label for="open_button" tabindex="0" title="Open file(s)">&#x1f4c2;&#xfe0e;</label>
    <button onclick="save()" aria-keyshortcuts="Ctrl+S" title="Save file [Ctrl+S]">&#x1f4be;&#xfe0e;</button>
    <button id="share_button" onclick="share()" title="Share">&#x1f517;</button>
    <a href="https://github.com/eyaler/ediking" target="_blank" title="GitHub">&#x1f431;</a>
  </div>
  
  <div id="textareas">
    <textarea id="code" autocomplete="off" autofocus oninput="update()">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ediKing</title>
  <style>
    body {
      align-items: center;
      background-image: radial-gradient(red 25%, transparent 0);
      background-repeat: space;
      background-size: 10vmin 10vmin;
      display: flex;
      flex-direction: column;
      font-size: max(2em, 5vw);
      justify-content: safe center;
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
    }
    
    body > * {
      background-color: #ff88;
      padding: .1em .3em;
    }
  </style>
</head>
<body>
  <h1>Why</h1>
  <h3>do you</h3>
  <h3>always</h3>
  <h6>sit on dots?</h6>
</body>
</html></textarea>
    <textarea id="prom" autocomplete="off" placeholder="Prompt here." rows="1"></textarea>
  </div>
  
  <iframe id="iframe"></iframe>
  
  <script>
    let active, writer, rewriter, controller, user_click
    
    function get_code_display() {
      return +new URLSearchParams(location.search).get('disp')
    }
    
    function update(hash=null) {
      if (hash != null) {
        const disp = get_code_display()
        if (disp) {
          if (!full.checked) full.click()
          if (disp == 2) controls.classList.add('conditional_hide')
          if (disp >= 3) controls.classList.add('hide')
        }
        if (!self.Writer || !self.Rewriter) {
          ai.disabled = true
          const label = ai.nextElementSibling
          label.role = 'link'
          label.onclick = () => open('https://developer.chrome.com/docs/ai/writer-api', '_blank')
          label.title = 'Writer/Rewriter APIs not supported\nClick for details!'
        } else if (!ai.checked)
          (async () => {
            if (await Writer.availability() == 'available' && await Rewriter.availability() == 'available') 
              ai.click()
          })()
        if (hash)
          code.value = decodeURIComponent(location.hash.slice(1))
      }
      active = document.activeElement
      iframe.srcdoc = code.value
      if (hash == null)
        history.replaceState(history.state, '', '#' + encodeURIComponent(code.value))
    }
    
    iframe.addEventListener('load', () => {
      if (typeof active != 'undefined')
        active.focus()
      const title = iframe.contentDocument.title
      if (title)
        document.title = title
      document.head.querySelectorAll('link[rel=icon]').forEach(e => e.remove())
      iframe.contentDocument.head.querySelectorAll('link[rel=icon]').forEach(e => document.head.appendChild(e))
      iframe.contentDocument.querySelectorAll('a').forEach(a => {
        if (a.origin != location.origin)
          a.target = '_blank'
      })
    })
    
    
    // Toggle buttons
    
    full.addEventListener('change', () => {
      const disp = get_code_display()
      let state = ''
      if (!full.checked && disp == 1)
        state = '?'
      else if (full.checked && !disp)
        state = '?disp=1'
      if (state)
        history.replaceState(history.state, '', state + location.hash)
      full.ariaExpanded = !full.checked
    })
  
    function set_wrap() {
      textareas.querySelectorAll('textarea').forEach(e => e.style.whiteSpace = wrap.checked ? 'pre-wrap' : 'pre')
    }
    
    wrap.addEventListener('change', () => set_wrap())
    set_wrap()
    
    
    // LLM stuff
    
    const shared_context = 'Output only a complete single-file HTML code (including CSS/JS inside). JS libraries can be used from CDN. NO external files!'
    
    function monitor(m) {
      m.addEventListener('downloadprogress', e => {if (prom.readOnly) prom.value = `Downloading model... ${e.loaded * 100 | 0}%`})
    }
    
    ai.addEventListener('change', async () => {
      if (ai.checked) {
        if (!writer || !rewriter) {
          const saved_prompt = prom.value
          prom.readOnly = true
          prom.value = 'Loading model...'
          run_stop.classList.add('hide')
          try {
            if (!writer) {
              writer = true
              const monitor_opt = await Writer.availability() != 'available' ? {monitor} : {}
              writer = await Writer.create({...monitor_opt, sharedContext: shared_context, length: 'long'})
            }
            if (!rewriter) {
              rewriter = true
              const monitor_opt = await Rewriter.availability() != 'available' ? {monitor} : {}
              rewriter = await Rewriter.create(monitor_opt)
            }
            prom.removeAttribute('readonly')
            run_stop.classList.remove('hide')
          } catch (error) {
            if (writer === true)
              writer = false
            if (rewriter === true)
              rewriter = false
            alert(error)
            ai.checked = false
          }
          prom.value = saved_prompt
        }
        if (user_click && !prom.readOnly)
          prom.focus()
          user_click = true
      } else
        code.focus()
      ai.ariaExpanded = ai.checked
    })
  
    async function run_stop_gen() {
      if (run_stop.classList.contains('thinking'))
        controller.abort()
      else {
        code.readOnly = true
        controller = new AbortController()
        let stream
        let resp = ''
        let pre_text = ''
        let post_text = ''
        run_stop.classList.add('thinking')
        const start = code.selectionStart
        const end = code.selectionEnd
        let code_text = code.value
        let prompt_text = prom.value.trim()
        const orig_length = code_text.length
        const abort_signal = {signal: controller.signal}
        try {
          if (!code_text.trim() && prompt_text)
            stream = await writer.writeStreaming(prompt_text, abort_signal)
          else {
            if (start < end && end - start < code_text.length) {
              //prompt_text += `\n\nRewrite only the selected code which is part of the full single-file HTML code (including CSS/JS inside):\n${code_text.trim()}`.trim()
              pre_text = code_text.slice(0, start)
              post_text = code_text.slice(end)
              code_text = code.value.slice(start, end)
            } else
              prompt_text = `${shared_context}\n\n${prompt_text}`
            stream = await rewriter.rewriteStreaming(code_text.trim(), {context: prompt_text, ...abort_signal})
          }
          for await (const chunk of stream) {
            resp += chunk
            resp = resp.replace(/^```(html|css|javascript|js)\r?\n?/, '')
            code.value = pre_text + resp + post_text
          }
          code.value = pre_text + resp.replace(/\r?\n?```$/, '') + post_text
          update()
          code.selectionStart = start
          code.selectionEnd = end + code.value.length - orig_length
        } catch (error) {
          if (error.name == 'QuotaExceededError')
            alert(`Error: LLM input (code + prompt) is ${error.requested.toLocaleString()} tokens,\nbut model is limited to ${error.quota.toLocaleString()} tokens.`);
          if (error.name != 'AbortError')
            alert(error)
        }
      }
      run_stop.classList.remove('thinking')
      code.removeAttribute('readonly')
    }
    
    
    // New, open, save, share
    
    function new_editor(e) {
      url = location.pathname + location.search
      if (e.ctrlKey || e.metaKey || e.button == 1)
        window.open(url, '_blank')
      else
        location = url
    }
    
    function open_files(files) {
      let have
      ;[...files].forEach(file => {
        const reader = new FileReader()
        reader.onload = () => {
          if (have)
            code.value += '\n\n'
          else
            code.value = ''
          let content = reader.result
          const indented = `\n\t\t${content.split('\n').join('\n\t\t')}\n\t`
          if (file.name.endsWith('.css') || file.type == 'text/css')
            content = `\t<style>${indented}</style>`
          else if (file.name.endsWith('.js') || file.type == 'application/x-javascript')
            content = `\t<script>${indented}<\/script>`
          code.value += content
          have = true
          update()
        }
        reader.readAsText(file)
      })
    }
    
    document.body.addEventListener('dragover', e => {
      if ([...e.dataTransfer.types].some(t => t == 'Files')) {
        e.preventDefault()
        e.dataTransfer.dropEffect = 'copy'
      }
    })
    
    document.body.addEventListener('drop', e => {
      const files = e.dataTransfer.files
      if (!files.length)
        return
      e.preventDefault()
      open_files(files)
    })
    
    open_button.addEventListener('change', e => open_files(e.currentTarget.files))
    
    function save() {
      const file = new Blob([code.value], {type: 'text/html'})
      const a = document.createElement('a')
      a.href = URL.createObjectURL(file)
      a.download = 'index.html'
      a.click()
    }
    
    if (!navigator.share) {
      share_button.title = 'Copy shareable link'
    }
    
    function share() {
        navigator.share?.({url: location.href}).catch(() => {}) ?? navigator.clipboard.writeText(location.href)
    }


    // Keyboard input

    document.addEventListener('keydown', e => {
      if (!e.altKey && !e.getModifierState?.('AltGraph') && (e.ctrlKey || e.metaKey) &&
        (e.code == 'KeyF' && e.shiftKey && get_code_display() < 3 || (e.key == 'Enter' && writer && rewriter || e.code == 'KeyS') && !e.shiftKey)) {
        e.preventDefault()
        if (e.code == 'KeyF')
          full.click()
        else if (e.key == 'Enter')
          run_stop_gen()
        else if (e.code == 'KeyS')
          save()
      }
    })
    
    controls.querySelectorAll('label').forEach(label => label.addEventListener('keydown', e => {
      if ((e.key == 'Enter' || e.key == ' ') && !e.altKey && !e.getModifierState?.('AltGraph') && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        e.preventDefault()
        label.click()
      }
    }))
    
    textareas.addEventListener('keydown', e => {
      if (document.execCommand && (e.key == 'Enter' || e.key == 'Tab') && !e.altKey && !e.getModifierState?.('AltGraph') && !e.ctrlKey && !e.metaKey) {
        e.preventDefault()
        const textarea = e.target
        const start = textarea.selectionStart
        const text = textarea.value
        if (e.key == 'Enter')
          document.execCommand('insertText', false, '\n' + text.slice(text.lastIndexOf('\n', start - 1) + 1).match(/^[ \t]*/))
        else if (e.key == 'Tab') {
          const end = textarea.selectionEnd
          textarea.selectionEnd = start
          if (!e.shiftKey)
            document.execCommand('insertText', false, '\t')
          else if (text[start - 1]?.match(/\s/))
            document.execCommand('delete')
          textarea.selectionEnd = textarea.selectionStart + end - start
        }
      }
    })
  </script>
</body>
</html>